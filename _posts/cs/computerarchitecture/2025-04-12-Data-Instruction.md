---
layout: post
title: "[Computer Architecture] 데이터와 명령어"
date: 2025-04-12 13:20 +09:00
categories: cs computerarchitecture
tags:
    [
        github,
        tech,
        blog,
        computer,
        architecture,
        data,
        instruction
    ]
---

> **3줄 요약**
<br>컴퓨터는 **데이터와 명령어**를 이해하고 처리하며 작동!
<br>데이터: 문자, 숫자, 이미지 등 **정보를 표현하는 기본 단위**
<br>명령어: 데이터를 **어떻게 처리할지 지시하는 명령**
{: .prompt-tip }

# 💻 컴퓨터 구조 & 운영체제 시리즈

> 이 시리즈는 『혼자 공부하는 컴퓨터 구조+운영체제』 (강민철 저) 
> <br> + 인프런 강의를 기반으로 **개인적으로 복습 및 정리한 기록**입니다.

---

# 💾 데이터와 명령어

> 컴퓨터는 눈에 보이지 않는 숫자와 기호들을 처리하면서 돌아가요.  
> 이 글에서는 **컴퓨터가 이해하는 정보인 '데이터'와 '명령어'**에 대해 정리해볼게요!

---

## 📦 데이터 (Data)

### 🔹 정보의 단위

| 단위 | 설명 |
|------|------|
| **비트(bit)** | 0과 1을 표현하는 가장 작은 단위 (2ⁿ 표현 가능) |
| **바이트(byte)** | 8비트 |
| **킬로바이트(kB)** | 1000 바이트 |
| **메가바이트(MB)** | 1000 kB |
| **기가바이트(GB)** | 1000 MB |
| **테라바이트(TB)** | 1000 GB |
| **워드(word)** | CPU가 한 번에 처리할 수 있는 데이터 단위<br>(half, full, double word 등) |



### 🔹 이진법과 음수 표현

- 컴퓨터는 **2진수(0과 1)** 로만 계산
- **음수 표현**: 2의 보수 사용
  - 0과 1을 반전하고 1을 더함
  - 예: `-5`를 표현하기 위해 `5`의 2의 보수 사용
- CPU는 연산 결과에 따라 **flag**로 양/음/오버플로우 등을 판단함



### 🔹 16진법 (Hexadecimal)

- 이진수가 너무 길어지는 것을 방지
- 4비트를 한 자리로 축약 → 예: `1111` → `F`



### 🔹 문자 데이터와 인코딩

#### ✅ 문자 집합 (Character Set)

- 컴퓨터가 이해할 수 있는 **문자의 모음**

#### ✅ 인코딩 & 디코딩

- **인코딩**: 문자를 0과 1의 이진수로 변환  
- **디코딩**: 이진수를 다시 문자로 변환

#### ✅ ASCII

- 초기 문자 인코딩 방식 (7비트)
- 영어, 숫자, 일부 특수문자만 표현
- **8비트 중 1비트는 오류 검출용 패리티 비트**

#### ✅ 유니코드 (Unicode)

- 전 세계 문자를 하나의 체계로 표현
- 이모지, 한글 등 다국어 지원 가능
- **인코딩 방식**:
  - `UTF-8`: 가변 길이 (1~4바이트)
  - `UTF-16`, `UTF-32` 등

---

## 🧾 명령어 (Instruction)

> **컴퓨터에게 시키는 일**을 구체적으로 표현한 것

### 🔹 고급 언어 vs 저급 언어

| 구분 | 설명 |
|------|------|
| **고급 언어** | 사람이 이해하기 쉬운 언어 (예: C, Python, Java) |
| **저급 언어** | 컴퓨터가 바로 이해하는 언어 (기계어, 어셈블리어) |

- **컴파일 언어**: 전체 코드를 기계어로 번역한 후 실행  
- **인터프리터 언어**: 한 줄씩 바로 실행 (예: Python)



### 🔹 기계어와 어셈블리어

- **기계어**: 0과 1로 이루어진 명령어
- **어셈블리어**: 사람이 읽기 쉽게 기계어를 문자로 바꾼 언어



### 🔹 명령어의 구성

> 명령어 = `연산코드(opcode)` + `오퍼랜드(operand)`

- **연산코드**: 어떤 연산을 할지
- **오퍼랜드**: 연산에 사용할 데이터 or 데이터의 위치

#### 연산코드 예시

1. 데이터 전송 (move)
2. 산술/논리 연산 (add, sub, and, or)
3. 흐름 제어 (jump, call)
4. 입출력 제어

---

## 📍 명령어 주소 지정 방식

### 🔸 유효 주소 (Effective Address)

- 실제로 데이터를 **어디서 가져올지**에 대한 주소

### 🔸 주소 지정 방식 (Addressing Mode)

| 방식 | 설명 | 특징 |
|------|------|------|
| **즉시 (Immediate)** | 오퍼랜드 필드에 **연산에 사용할 값 자체**를 직접 명시 | 실행 빠름, 메모리 접근 없음 |
| **직접 (Direct)** | 오퍼랜드가 **데이터가 저장된 메모리 주소** | 단순하지만 주소 변경 어려움 |
| **간접 (Indirect)** | 오퍼랜드가 **데이터의 주소를 저장하고 있는 주소** | 유연하지만 속도 느림 |
| **레지스터 (Register)** | 오퍼랜드가 **레지스터를 직접 명시** | 매우 빠름, 메모리 접근 없음 |
| **레지스터 간접 (Register Indirect)** | 오퍼랜드가 **데이터 주소를 저장한 레지스터** | 메모리 접근 가능 + 빠른 속도 |

> ✅ 일반적으로 레지스터는 메모리보다 **훨씬 빠름!**

---

## ✅ 마무리 정리

> 컴퓨터는 단순한 명령어와 데이터를 조합해  
> 우리가 사용하는 복잡한 프로그램을 실행해요.  

이해하기 어려울 수 있지만,  
기본 개념만 알아도 컴퓨터가 **어떻게 작동하는지** 감 잡을 수 있어요!  

> ✨ 다음 편에서는 **CPU의 구조와 동작 방식**을 정리해볼게요!

---

## 📚 참고 자료

- 『혼자 공부하는 컴퓨터 구조+운영체제』 - 강민철 저  
- [인프런 강의 - 혼자 공부하는 컴퓨터 구조+운영체제 기반 강의](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)
{: target="_blank"}

---

읽어주셔서 감사합니다!  
잘못된 부분이나 궁금한 점은 댓글이나 GitHub Issue로 자유롭게 알려주세요 😊
