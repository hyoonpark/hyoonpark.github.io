---
layout: post
title: "[OS] 가상 메모리"
date: 2025-05-06 21:00 +09:00
categories: cs os
tags: [github, tech, blog, operating, system, 가상메모리, virtualmemory]
---

> **3줄 요약**
<br>가상 메모리는 실제 메모리보다 큰 프로그램을 실행할 수 있도록 돕는 메모리 관리 기술
<br>페이징을 활용해 연속할당의 단점을 보완하며, 주소 변환과 페이지 교체 알고리즘으로 성능을 관리
<br>스래싱을 방지하기 위해 다양한 프레임 할당 방식과 작업 집합 모델이 사용됨
{: .prompt-tip }

# 💻 컴퓨터 구조 & 운영체제 시리즈

> 이 시리즈는 『혼자 공부하는 컴퓨터 구조+운영체제』 (강민철 저)
> <br> + 인프런 강의를 기반으로 **개인적으로 복습 및 정리한 기록**입니다.

---

## 📌 가상 메모리란?

물리 메모리보다 큰 프로그램을 실행하기 위해 **실행에 필요한 부분만 메모리에 올려서** 실행하는 메모리 관리 기법입니다.

- 연속 메모리 할당의 한계 → 외부 단편화 문제 발생
- 스와핑(Swapping)을 통해 메모리 활용을 유동적으로 처리
- 페이지 단위로 분할하여 관리 → 페이징 기반 가상 메모리

---

## 📁 연속 메모리 할당과 외부 단편화

### 스와핑(Swapping)

현재 사용하지 않는 프로세스를 **보조기억장치로 이동**시키고, 빈 공간에 다른 프로세스를 적재하는 방식입니다.

- Linux에서 스왑 메모리 확인:
```bash
free -h
top
```

### 메모리 할당 방식

- **First-Fit**: 처음 맞는 공간에 할당
- **Best-Fit**: 딱 맞는 가장 작은 공간에 할당
- **Worst-Fit**: 가장 큰 공간에 할당

### 외부 단편화 (External Fragmentation)

- 작은 빈 공간들이 흩어져 있어 큰 프로세스를 적재하지 못하는 상황
- 해결 방법: **압축(Compaction)** 또는 **페이징**

---

## 🧱 페이징(Paging)을 통한 가상 메모리

### 개념

- 프로그램을 일정 크기의 **페이지(Page)** 단위로 쪼개서, 물리 메모리의 **프레임(Frame)**에 할당
- 불연속적인 물리 메모리 할당 가능

### 페이지 테이블(Page Table)

- 페이지 번호 ↔ 프레임 번호를 매핑
- **내부 단편화** 가능성 존재 (예: 프로세스 108KB, 페이지 크기 10KB → 2KB 낭비)

- 페이지 크기 확인:
```bash
getconf PAGESIZE
```

### 주소 변환

- **논리주소 = 페이지 번호 + offset**
- → 페이지 테이블을 통해
- **물리주소 = 프레임 번호 + offset**

### PTBR (Page Table Base Register)

- CPU가 현재 프로세스의 페이지 테이블을 가리킴

### TLB (Translation Lookaside Buffer)

- 페이지 테이블의 **캐시 역할**
- TLB hit / miss 성능에 큰 영향

---

## 🔍 페이지 테이블 엔트리(PTE) 구성 요소

- 페이지 번호, 프레임 번호
- **유효 비트**: 접근 가능 여부 → 0이면 페이지 폴트 발생
- **보호 비트**: 읽기/쓰기 권한
- **참조 비트**: 접근 여부 기록
- **수정 비트 (dirty bit)**: 쓰기 여부 기록

---

## ✂️ 쓰기 시 복사 (Copy-On-Write)

- fork 시 부모의 페이지를 자식이 **공유**
- 쓰기 발생 시 복제하여 메모리 절약 및 성능 향상

---

## 📚 계층적 페이징 (Multilevel Paging)

- **모든 페이지 테이블을 메모리에 유지하지 않고** 계층 구조로 관리
- 페이지 테이블도 페이지화함

---

## 📥 요구 페이징 (Demand Paging)

- 처음부터 모든 페이지를 올리지 않고 **필요한 페이지만 적재**
- 페이지 폴트 → 페이지 교체 발생 가능

---

## 🔄 페이지 교체 알고리즘

| 알고리즘       | 방식                       | 장점                       | 단점                    |
|----------------|----------------------------|----------------------------|-------------------------|
| FIFO           | 가장 오래된 페이지 교체    | 구현 쉬움                  | 장기 거주 페이지 문제   |
| Second-Chance  | 참조 비트로 기회 부여      | FIFO 개선                 | 약간의 오버헤드 발생    |
| LRU            | 가장 오래 사용 안 한 페이지| 성능 우수                  | 구현 복잡               |
| Optimal        | 가장 오래 사용 안 할 페이지| 이론적으로 최적            | 미래 예측 불가로 구현 어려움 |

### 페이지 참조열

- 연속된 페이지 요청 중복 제거하여 페이지 폴트 최소화 분석

### 알고리즘 종류

- **FIFO**: 가장 먼저 들어온 페이지 교체
- **Second-Chance**: 참조 비트 활용하여 기회 제공
- **Optimal**: 앞으로 가장 오래 사용되지 않을 페이지 교체 (이론상 최적)
- **LRU**: 가장 오랫동안 사용되지 않은 페이지 교체

---

## 🧩 프레임 할당 기법

### 문제: 스래싱 (Thrashing)  

![스래싱](assets/img/cs/thrashing.png)  
<sub>출처: 『혼자 공부하는 컴퓨터 구조+운영체제』 - 강민철 저</sub>

- 프로세스가 페이징에만 시간을 소비 → 성능 급감

### 할당 방식

- **균등 할당**: 모든 프로세스에 동일한 프레임
- **비례 할당**: 프로세스 크기에 비례하여 프레임 할당
- **작업 집합 모델**: 일정 시간 내 참조한 페이지 집합에 따라 프레임 결정
- **페이지 폴트 빈도 기반**: 페이지 폴트율에 따라 프레임 수 조절

---

## 🛠️ 내용 보완 및 추가 설명
<details>
<summary>추가 설명</summary>
<div markdown="1">

### 📌 스와핑의 현대적 의미

> 기존 설명: 사용되지 않는 프로세스를 보조기억장치의 스왑 영역으로 이동

- 현대 운영체제에서는 전체 프로세스를 통째로 스와핑하는 경우보다,  
  **페이징 기반의 부분 스와핑(page swapping)** 방식이 일반적이다.
- 즉, **프로세스의 일부분인 페이지 단위**로 메모리에서 보조기억장치로 이동하고 다시 적재한다.

---

### 📌 PTBR와 TLB 보완 설명

> 기존 설명: 페이지 테이블이 메모리에 존재하면 메모리 접근 시간이 2배

- 더 정확하게는, **페이지 테이블 접근 + 실제 데이터 접근 → 메모리 접근 2회 발생**
- 이를 줄이기 위해 **TLB(Translation Lookaside Buffer)**가 사용된다.
  - 페이지 테이블의 일부를 캐싱하여 빠르게 참조 가능
  - TLB Hit → 빠르게 변환, TLB Miss → 메모리 접근 2번 수행

---

### 📌 LRU의 구현 현실성

- LRU(Least Recently Used)는 **가장 오랫동안 사용되지 않은 페이지**를 교체
- 그러나 이를 정확하게 구현하려면, 모든 페이지 접근 시간을 추적해야 하므로  
  **하드웨어적 지원** 또는 **근사 알고리즘**이 필요하다.

💡 대표적인 근사 알고리즘: **Clock 알고리즘** (→ Second-Chance와 유사)

---

### 📌 Copy-on-Write(COW) 예외 보완

- `fork()` 후 부모와 자식 프로세스는 페이지를 공유한다.
- 단, 자식이 `exec()` 시스템 호출을 수행하면 **자체 프로그램으로 메모리가 교체**된다.  
  → 이 경우 COW(shared page)는 더 이상 유지되지 않는다.

---

### 📌 스래싱(thrashing) 원인 보완

> 기존 설명: 페이징에 너무 많은 시간이 소요되어 성능 저하

- 실제로는 **디스크 I/O 병목**이 발생하며 시스템 전체 성능이 급격히 저하된다.
- 작업 집합 크기보다 적은 프레임을 가진 프로세스가 많을수록 스래싱 가능성이 커진다.

</div>
</details>

---

## 🧩 추가로 알면 좋은 개념
<details>
<summary>추가 개념</summary>
<div markdown="1">

### 📌 세그멘테이션(Segmentation)

- 페이징 외의 가상 메모리 기법으로, **크기가 가변적인 논리 단위(세그먼트)**를 기준으로 메모리를 나눈다.
  - 예: 코드 세그먼트, 데이터 세그먼트, 스택 세그먼트 등
- 외부 단편화 발생 가능성이 존재하지만, **논리적 의미 단위로 접근이 유리**한 장점이 있다.

---

### 📌 Clock (Second-Chance) 페이지 교체 알고리즘

- LRU의 근사 기법으로 실제 운영체제에서 널리 사용
- **원형 큐 형태로 페이지 프레임을 순환**하며, 참조 비트가 0인 페이지를 교체 대상으로 선택한다.
- 참조 비트가 1이면 0으로 리셋하고 다음 페이지 확인

---

### 📌 실제 운영체제 예시 (리눅스 기준)

- 리눅스는 다음의 방식으로 가상 메모리를 관리함:
  - **Demand Paging + Copy-on-Write**
  - 페이지 교체 시 **LRU 근사 알고리즘 (Clock 방식)** 사용
  - `/proc` 파일 시스템에서 메모리 정보 확인 가능

</div>
</details>

---

## ✅ 마무리 정리

가상 메모리는 **물리 메모리를 효율적으로 활용**할 수 있도록 도와주는 핵심 기술  
페이징 기법과 다양한 페이지 교체 알고리즘을 통해 성능을 유지하며,  
스래싱을 방지하기 위해 작업 집합, PFF, 다양한 할당 기법이 활용

---

## 📚 참고 자료

- 『혼자 공부하는 컴퓨터 구조+운영체제』 - 강민철 저  
- [인프런 강의 - 혼자 공부하는 컴퓨터 구조+운영체제 기반 강의](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)  
{: target="_blank"}

---

읽어주셔서 감사합니다 🙌  
내용이 도움이 되었거나, 틀린 부분이 있다면 댓글이나 GitHub Issue로 알려주세요 😊
